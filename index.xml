<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>crupest 的博客</title><link>https://crupest.cn/</link><description>Recent content on crupest 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>crupest. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Sat, 27 Jun 2020 02:00:00 +0800</lastBuildDate><atom:link href="https://crupest.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>失眠夜晚的闲聊</title><link>https://crupest.cn/posts/free-chat-on-restless-night/</link><pubDate>Sat, 27 Jun 2020 02:00:00 +0800</pubDate><guid>https://crupest.cn/posts/free-chat-on-restless-night/</guid><description>crupest 的博客 https://crupest.cn/posts/free-chat-on-restless-night/ -&lt;p>这一次我没有打算写很长的内容。仅仅只是想借写这篇博客的功夫来打发一下我睡觉之前这段失眠的夜晚。&lt;/p>
&lt;h1 id="更新">更新&lt;/h1>
&lt;p>我很喜欢新的事物，尤其是计算机相关的。新的软件一般都是漂亮的，也许是因为它本身很漂亮，也许是因为我喜新厌旧的新鲜感。&lt;/p>
&lt;p>我今天晚上一口气更新了好几个新的事物，容我一一道来。&lt;/p>
&lt;h2 id="手机输入法">手机输入法&lt;/h2>
&lt;p>晚上的时候，我看到小米自带的输入法得到了更新。由于我很无聊，又对现在用的QQ输入法的英文输入功能非常不满意，尤其是它每次大写开启后会自动锁定，而不是只对下一个字母生效，导致在写英语句子的时候非常的不爽。之前系统自带的输入法好像也是不能的，但是，我尝试 give it a try，结果令我意外的是，它把这个功能加上去了。而我又一直很喜欢自带的这个输入法的音效，以及我比较喜欢原生（或者说自带）的东西，所以我就几乎毫不犹豫的切换回来了。&lt;/p>
&lt;p>不过自带的这个输入法还是有缺点，那就是英文输入还是不够丝滑。以及其他的一些操作逻辑不太完美。还有广告功能很多，不过好在可以关闭大部分。&lt;/p>
&lt;h2 id="博客">博客&lt;/h2>
&lt;p>我给博客的生成架构进行了重构，主要是为了让他用上 GitHub Actions 的自动 CI 构建系统。我把博客的源代码开源了。之前不开源是因为我怕有人轻易地就滥用了。但是只有 public 的项目才可以享受无限制的 GitHub Actions 服务，加之我觉得生成的网页也很好爬，如果硬要滥用的话，所以我还是把它开源了。&lt;/p>
&lt;p>我把源代码移到了部署仓库的 source 分支，同时加上了 CI 。当然早就有人已经做过了这种东西，所以相关的资源配置也都轻轻松松。如果将来我愿意，我再开一篇技术博客来讲。&lt;/p>
&lt;p>于是，从现在开始，我不要自己运行 hugo 去构建和部署，只需要专心写文章就行了。&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>除了上述两个，最近还有不少新玩意儿。比如我更新了 Windows 10 2004，在经过一段时间的等待之后。最大的好处就是，微软中文输入法得到了更新。新版的微软输入法修复了Ctrl+空格这个快捷键不能取消的问题。而且换上了一套新的皮肤。&lt;/p>
&lt;p>另一个就是 GitHub 的 UI 得到了全面的升级，新 UI 显得更清爽现代了。不过还要花一段时间去适应。这点我跟一些人不一样，我乐于去适应这些新的好的玩意儿。&lt;/p>
&lt;h1 id="关于失眠本身">关于失眠本身&lt;/h1>
&lt;p>其实我本来是想写一篇博客来分析一下我为什么会失眠。但是我在到处晃悠了一会儿之后，还是想写一些其他的东西，而不是那些让人沮丧的东西。&lt;/p>
&lt;p>前几天晚上写 CruUI 写得有点过火，导致这几天生物钟都调不过来了。&lt;/p>
&lt;p>而且我感觉有些燥热，所以我还狠下心来开了空调，虽然温度并不是很高。空调经过修理之后，噪音小了很多，但还是有一点，特别是在特定情况下，不过至少比之前好了很多。&lt;/p>
&lt;p>现在已是将近凌晨3点，我想，现在睡觉，应该不会睡不着了。&lt;/p>
&lt;h1 id="第二天的补充">第二天的补充&lt;/h1>
&lt;p>这篇博客是昨天晚上（准确的说是今天凌晨）在手机上用 Office 写的，然后用 pandoc 转换成 markdown 格式。算是一个新的尝试吧。&lt;/p>
- https://crupest.cn/posts/free-chat-on-restless-night/ - crupest. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>关于我——crupest</title><link>https://crupest.cn/about/</link><pubDate>Fri, 19 Jun 2020 23:45:08 +0800</pubDate><guid>https://crupest.cn/about/</guid><description>crupest 的博客 https://crupest.cn/about/ -&lt;h1 id="自我介绍">自我介绍&lt;/h1>
&lt;p>姓名： crupest（我是不会轻易地告诉你我的真名的！）&lt;/p>
&lt;p>性别：男&lt;/p>
&lt;p>学校：武汉轻工大学，计算机专业&lt;/p>
&lt;p>爱好：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>写代码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>和好朋友玩&lt;/p>
&lt;/li>
&lt;li>
&lt;p>英雄联盟&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>天敌：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>运动&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运动&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运动&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>传送门：&lt;a href="https://github.com/crupest">GitHub&lt;/a>&lt;/p>
&lt;h1 id="关于博客">关于博客&lt;/h1>
&lt;p>本博客采用 &lt;a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC 4.0 协议&lt;/a> 。&lt;/p>
- https://crupest.cn/about/ - crupest. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>期末考试后的分裂</title><link>https://crupest.cn/posts/splitting-after-final-tests/</link><pubDate>Fri, 19 Jun 2020 00:25:07 +0800</pubDate><guid>https://crupest.cn/posts/splitting-after-final-tests/</guid><description>crupest 的博客 https://crupest.cn/posts/splitting-after-final-tests/ -&lt;h1 id="写在前面的话">写在前面的话&lt;/h1>
&lt;p>我也想不到，我的博客最终成了我的”个人情感日记本“。其实我一开始是想写一些关于编程的技术文章。可惜我太懒了，懒得去写那些正经事，写这种牢骚记录倒是非常勤快。我大概已经想不出准确的词语来描述这个博客的性质了。&lt;/p>
&lt;p>我也不知道，把这些东西写在公开的地方好不好。为什么我不搞一个私密的日记本，因为我觉得如果写东西没有别人看的话，那就没啥意义了。我是说我觉得没啥意义，有的人也许会觉得写私密的日记是一件很享受的事情。&lt;/p>
&lt;p>大部分博主应该都是去在博客上分享一些美好的东西，比如美食、旅行记录什么的。但我的意向显然不在此。因为我完全不懂得那些浪漫的东西，也不懂得装饰生活。&lt;/p>
&lt;p>当我遇到好吃的东西的时候，我想到的更多的是怎么把享受美食的感觉留下来，而不是着急着去给美食做一篇正儿八经的说明文。&lt;/p>
&lt;h1 id="分裂的现实">分裂的现实&lt;/h1>
&lt;p>在我最近的生活中，分裂的东西很多，比如你在头图中看到的分裂的成绩。&lt;/p>
&lt;p>今天本来应该是个开心的一天，因为我结束了为期4天的连环期末考试，也收到了新买的耳机。但是也遇到不愉快的事情，比如跟好朋友闹了点小矛盾，比如本以为修好的空调”又“坏了。&lt;/p>
&lt;h1 id="分裂的心情">分裂的心情&lt;/h1>
&lt;p>我今天的心情就像一个过山车，忽上忽下，一会儿感到莫名兴奋，一会儿又感到莫名憋屈，就像一个双相情感障碍患者。老实说，我不是很喜欢这种感觉。但是转念一想，这比一直处在抑郁状态还是好一点。&lt;/p>
&lt;p>不过，谁的心情还没有个起起落落呢？所以我一直在想，这是不是就是生活的滋味。人生就是如此的分裂，充斥着相反的情绪。&lt;/p>
&lt;h1 id="分裂的反应">分裂的反应&lt;/h1>
&lt;p>我一直在试图整理我自己的情绪，而整理的办法的其中之一就是你现在正看到的这篇文章。&lt;/p>
&lt;p>每当我低落的情绪涌上来，我的自我检查机制就会迅速反应。我在想为什么跟好朋友闹了一点小矛盾，我却不能释怀，为什么空调坏了我想到的不是怎么修它，还是感受到了一种沉重的麻烦。不过，我都没有得到结果。没办法，我的自我理解机制就是如此的薄弱。&lt;/p>
&lt;p>不过话又说回来，至少我意识到了这些种种不愉快，而不是被考完的喜悦冲昏了头脑，否定了所有的情绪。当我想到这一层，我心中的不快得到了些许的溶解。&lt;/p>
&lt;p>每当我高兴的情绪涌上来，我都会仔细的去回味那种快乐的感觉，那种满足感，让甜美的感觉得以充分的享受，甚至尽可能让它延续下去。&lt;/p>
&lt;p>当我意识到生命中有一部分是快乐，我不敢说生命是完美的，但至少它是丰富充实的。至少你咬到的那一口，不尽是苦味。&lt;/p>
&lt;h1 id="结语">结语&lt;/h1>
&lt;p>我又成功的写了一篇泥巴文章，它是那样的不成形。不过我还是那句话，我压根就没想着写什么正儿八经的东西。我反复强调这一点，就是想要自己放松下来，写点自己顺着流淌出来的东西。&lt;/p>
&lt;p>现在它流完了，我也该继续去享受这个美妙的夜晚。&lt;/p>
- https://crupest.cn/posts/splitting-after-final-tests/ - crupest. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>期末考试前的自我救赎</title><link>https://crupest.cn/posts/self-salvation-before-final-tests/</link><pubDate>Sat, 06 Jun 2020 22:11:24 +0800</pubDate><guid>https://crupest.cn/posts/self-salvation-before-final-tests/</guid><description>crupest 的博客 https://crupest.cn/posts/self-salvation-before-final-tests/ -&lt;h1 id="我在写什么">我在写什么&lt;/h1>
&lt;p>我已经好久没有写很长的东西了，更不用说写这种还会公开发表在自己的博客上的内容。如果不是要放在博客上，我可能也不会有动力去写，毕竟我不是那种喜欢自己写了东西留作纪念的人。当然，也不是说不留作纪念，这只是一部分目的，还有一部分就是为了写给别人看。说不定哪天某个“天涯沦落人”偶然间看到了，多少能够引起一些感情。&lt;/p>
&lt;p>那我要写些什么呢？我想写的东西很多，不过没有一个是正儿八经的逻辑思维上的成果，都是些我的碎碎念。我不善于发表自己的什么宏观上的大思想，因为怕放到网上会遭受抨击。不过写起这种叫做 jibber-jabber 的东西，我是一套又一套。可能这就是多愁善感的人的一个特点，遇到芝麻大点的事，只要是能引起自己的什么感觉，就想写下来。&lt;/p>
&lt;p>不过，这次写这个随笔，最主要的原因，还是因为，期末考试快来了，在压力的边缘，我想做点简单的又有成就感的事——那就是写这篇随笔。再说大点，就是给我的博客增添一点新的血液，多愁善感倒是其次。&lt;/p>
&lt;h1 id="期末考试怎么我了">期末考试怎么我了&lt;/h1>
&lt;p>你还记得这篇文章的标题吗？“期末考试前的自我救赎”。我为什么要救赎我自己，当然是因为我犯了点“错误”。不过，这个救赎并不意味着我把自己拉上正轨，而是把我拉到另一条大概也能走的轨道上。&lt;/p>
&lt;p>这篇文章写于 2020 年 6 月 6 日晚上，也就是我的网站开发大作业上交截止日子的前夕。但你可以料想到，我没有完成大作业，而且我已经放弃了。我在打出“放弃”这两个字的时候，甚至身体抖了一下。但是我确实要放弃了，这就是所谓的“错误”。而“救赎”就是我所写的这篇随笔，以及我脑子里全部的关于这个问题所进行的思想斗争。&lt;/p>
&lt;p>我很想说一说，期末考试前的这段时间我到底怎么了。但我不愿意。大概作为一个正常人，没有人会直接把自己内心深处的痛苦清晰的表达出来，然后发表在公开的地方。但如果你正在看这篇文章，那么你多少应该能够想象出一些这些废话到底表达着一种怎么样的情绪。如果你不能，那也没有问题。因为我压根就没想着一个人会多么深刻的理解另一个人，尤其是在那个人说着含糊不清毫无逻辑的话的时候。如果你能想象出一点，那我觉得这便是人生大幸。&lt;/p>
&lt;h1 id="我的选择">我的选择&lt;/h1>
&lt;p>我的选择就是放弃了网站开发大作业。但这只是一个暂时的逃避，这就已经说明了这个选择的后果。但我还是选择逃避，哪怕我知道后果。&lt;/p>
&lt;p>这到底是不是一个好的选择？&lt;/p>
&lt;p>它是我做的选择，所以它是好的。这句话可能会让你疑惑，为什么我做的选择就是好的。因为我相信人具有应激性，他的基因操控他会做出对自己最有利的选择。如果一个人处于极大的压力下，他又不能简单的处理掉这个问题，我是指，我无法在明天下午5点之前赶完我的大作业，那么逃避就是一个缓和情绪的最佳选择。&lt;/p>
&lt;p>这是一种曲线救国。就好比打游戏之于提升人的能力和境界有没有作用。如果抛开游戏本身的意义不谈，仅谈它的娱乐效应，答案也是肯定的。它只不过是在帮你放松，让你更有精力去做所谓的真正的有用的事。简单的说，它就是一块垫脚石。&lt;/p>
&lt;p>可惜，理论是美好的，人的情绪却不是完全由理智控制的。所以就算我明白以上这一点，但我还是为我的选择承担了不少的负面情绪。&lt;/p>
&lt;p>不过还好，我写了这篇随笔。&lt;/p>
&lt;h1 id="不仅仅是学习">不仅仅是学习&lt;/h1>
&lt;p>我在开篇就说过，这篇随笔没有中心。我不是写什么正儿八经的文章，所以我大可不必去纠结那些写文章的套路，我唯一的线索就是我的脑子在想什么。&lt;/p>
&lt;p>如果我的大脑每时每刻都在做思想斗争，那我现在应该精神分裂了。恰恰是因为我的生活里还有许多给我带来新鲜感的东西，我才活了下来。&lt;/p>
&lt;p>就像写这篇文章，我一开始就没打算围绕着期末考试讲个不停。&lt;/p>
&lt;p>那我还注意到了些什么。&lt;/p>
&lt;h2 id="写博客的工具">写博客的工具&lt;/h2>
&lt;p>这篇文章是用一个叫做 &lt;a href="https://github.com/marktext/marktext">Mark Text&lt;/a> 的软件写的。体验还可以，不过它目前处于测试阶段，有些许的bug和功能上的残缺，但总的来说还是不错的。我在Github上搜索了一会儿，找到了这个软件。一开始我就想找一个开源的 Markdown 编辑器，作为我的主力博客工具。因为用 VS Code 写这种文字性博客，实在是有点格格不入。&lt;/p>
&lt;h2 id="关于我的新博客">关于我的新博客&lt;/h2>
&lt;p>正如你所见，这篇文章会发布在博客上。这大概是我第三四次搭建博客了。在这期间，我试过了很多种博客的平台，包括 &lt;a href="https://hexo.io/">&lt;em>hexo&lt;/em>&lt;/a> 、 &lt;a href="https://github.com/halo-dev/halo">&lt;em>halo&lt;/em>&lt;/a> 之类的，光 &lt;em>hexo&lt;/em> 就搭了几次。现在用的是 &lt;a href="https://gohugo.io/">&lt;em>hugo&lt;/em>&lt;/a>。&lt;/p>
&lt;p>我是在申请 &lt;em>Let&amp;rsquo;s Encrypt&lt;/em> 的 SSL 证书时，发现他们官网用的是 &lt;em>hugo&lt;/em> 这个静态网站生成器，当时了解了一下感觉还不错。尤其是 &lt;em>hugo&lt;/em> 官网的宣传里说，它生成网站的速度很快。我探索了一下，发现它是 &lt;em>Go&lt;/em> 写的，然后我就明白了。然后我果断放弃了用 &lt;em>nodejs&lt;/em> 写的 &lt;em>hexo&lt;/em> 。而且 &lt;em>hugo&lt;/em> 的开发服务器可以热重载配置文件，但是 &lt;em>hexo&lt;/em> 的就不行。这一点在配置主题的时候还是很有用的。&lt;/p>
&lt;p>想搭博客的同学可以了解一下。&lt;/p>
&lt;h2 id="我的朋友们">我的朋友们&lt;/h2>
&lt;p>如果你让我想一些高兴的事，那我首先会想到的肯定是我的好朋友们。如果不是这段时间他们尽自己可能陪伴着我，我可能早就原地螺旋爆炸。我很想写一点东西或者发一点图片，但这些东西暂时只能留在我的心里了。因为网络实在是太过于凶险，博客上面放真实信息也不太好。不过将来我可能会匿名写点这方面的东西吧。但仅仅是可能。&lt;/p>
&lt;h1 id="结尾">结尾&lt;/h1>
&lt;p>万事有始有终，到结尾我也没什么特别想说的，我想说的都差不多说完了，我的表达欲也基本得到了满足。接下来就是去迎接期末考试这一系列麻烦的东西。再说近点，就是享受这个美好的晚上，享受上传这篇博客，以及等下吃东西的乐趣。&lt;/p>
- https://crupest.cn/posts/self-salvation-before-final-tests/ - crupest. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Self Resolvable</title><link>https://crupest.cn/posts/self-resolvable/</link><pubDate>Sun, 30 Jun 2019 18:21:30 +0800</pubDate><guid>https://crupest.cn/posts/self-resolvable/</guid><description>crupest 的博客 https://crupest.cn/posts/self-resolvable/ -&lt;p>我实在是不知道怎么把这个东西翻译成中文。&lt;/p>
&lt;p>任何事物的发明都有其起源。最近我在写我的那个 UI 库的时候发现了一个问题：&lt;/p>
&lt;p>每当我的某个控件改变一个关系到布局的属性时，我就必须得重新 Layout，但是如果在某一个消息的处理过程中，用户改变了两个这样的属性，那么就有可能会连续 Layout 两次，很明显前一次的 Layout 是不必要的。所以我就改成了每需要 Layout 的时候，就把 layout 设成脏的，然后再投递一个事件，在下一个消息循环 Layout，这样，即使用户连续改了两个属性，Layout 的消息也只投递了一次，只会进行一次 Layout。&lt;/p>
&lt;p>这样改了之后看似没有问题，但实际上又引入了一个潜在的 bug：万一用户改了两个属性之后又立即销毁了那个需要重新 Layout 的窗口呢？虽然说，好的写法应该是用户调用 InvokeLater 在下一个消息循环销毁窗口，但你不能对用户的行为做任何假定。于是，就需要在 Layout 消息处理中在真正 Layout 之前要判断一下窗口还在不在。&lt;/p>
&lt;p>自然的去想，我就需要一个独立于窗口之外的一个变量来存储这个窗口是否被销毁了，但这样感觉很麻烦，我想把这个属性直接写到窗口里面，于是就产生了这个叫做 self-resolvable 的东西。&lt;/p>
&lt;p>大致思路就是，有这个需要的对象应该提供一个接口&lt;code>CreateResolver&lt;/code>，调用这个接口你就能获得一个&lt;code>Resolver&lt;/code>，而这个&lt;code>Resolver&lt;/code>又有一个接口&lt;code>Resolve&lt;/code>，如果对象还在，那么调用它就返回这个对象，不然就返回&lt;code>null&lt;/code>。这样会很方便，因为所有的这些都是写在对象里面的，不需要在对象外面写额外的逻辑，而且上述的情况肯定不会只出现一次，如果我们把它抽象出来，那么就能一劳永逸。&lt;/p>
&lt;p>当然，我不会是第一个产生这种想法的人。实际上很多地方已经有了这个想法和实现。&lt;/p>
&lt;p>比如 Qt，我记得 Qt 里的&lt;code>QObject&lt;/code>都有一个销毁事件，在这个对象被销毁的时候，会发出一个信号。Qt 我不是很熟悉，但是这个功能对于写 UI 来说还是很有用的。&lt;/p>
&lt;p>我不使用 Qt，但实际上，C++标准库已经有了这个想法的实现，而且功能比我说的更强大。那就是&lt;a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">&lt;code>std::enable_shared_from_this&lt;/code>&lt;/a>。继承了这个类之后呢，你就可以随时从一个对象上调用&lt;code>shared_from_this&lt;/code>获取一个&lt;code>shared_ptr&lt;/code>，从而保证这个对象不会被销毁。如果你想要一个弱引用，那就可以调用一个&lt;code>weak_from_this&lt;/code>来获取一个&lt;code>weak_ptr&lt;/code>，但这个功能在 C++17 以后才有。标准库的这个功能，我也不是很熟悉，也从来没用过。&lt;/p>
&lt;p>最终我还是选择自己撸一套简陋的工具，来实现我的想法。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt; // for test output&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cassert&amp;gt; // for assert&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;memory&amp;gt; //for shared_ptr&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//forward declaration
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SelfResolvable&lt;/span>;
&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ObjectResolver&lt;/span> {
&lt;span style="color:#66d9ef">friend&lt;/span> SelfResolvable&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
ObjectResolver(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">*&amp;gt;&amp;amp;&lt;/span> resolver) &lt;span style="color:#f92672">:&lt;/span> resolver_(resolver) {}
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
ObjectResolver(&lt;span style="color:#66d9ef">const&lt;/span> ObjectResolver&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
ObjectResolver&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> ObjectResolver&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
ObjectResolver(ObjectResolver&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
ObjectResolver&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(ObjectResolver&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;span style="color:#f92672">~&lt;/span>ObjectResolver() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
T&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">Resolve&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;span style="color:#75715e">// resolver_ is null only when this has been moved.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// You shouldn&amp;#39;t resolve a moved resolver. So assert it.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> assert(resolver_);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>resolver_;
}
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">*&amp;gt;&lt;/span> resolver_;
};
&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SelfResolvable&lt;/span> {
&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
SelfResolvable() &lt;span style="color:#f92672">:&lt;/span> resolver_(&lt;span style="color:#66d9ef">new&lt;/span> T&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>))) {}
SelfResolvable(&lt;span style="color:#66d9ef">const&lt;/span> SelfResolvable&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
SelfResolvable&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> SelfResolvable&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
SelfResolvable(SelfResolvable&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
SelfResolvable&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(SelfResolvable&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>SelfResolvable() { (&lt;span style="color:#f92672">*&lt;/span>resolver_) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>; }
ObjectResolver&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> CreateResolver() { &lt;span style="color:#66d9ef">return&lt;/span> ObjectResolver&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>(resolver_); }
&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">*&amp;gt;&lt;/span> resolver_;
};
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">O&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> SelfResolvable&lt;span style="color:#f92672">&amp;lt;&lt;/span>O&lt;span style="color:#f92672">&amp;gt;&lt;/span> {};
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> o &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> O;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> resolver &lt;span style="color:#f92672">=&lt;/span> o&lt;span style="color:#f92672">-&amp;gt;&lt;/span>CreateResolver();
std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (resolver.Resolve() &lt;span style="color:#f92672">==&lt;/span> o) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;span style="color:#66d9ef">delete&lt;/span> o;
std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (resolver.Resolve() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码的核心思想，就是创建一个&lt;code>shared_ptr&amp;lt;T*&amp;gt;&lt;/code>，让所有的&lt;code>ObjectResolver&lt;/code>都保存这个&lt;code>shared_ptr&lt;/code>，而需要这个功能的类继承&lt;code>SelfResolvable&amp;lt;T&amp;gt;&lt;/code>，在构造的时候把这个&lt;code>shared_ptr&lt;/code>所包含的指针设为&lt;code>this&lt;/code>，在销毁的时候把它设为&lt;code>nullptr&lt;/code>。这样&lt;code>ObjectResolver&lt;/code>只需要通过这个指针就能获取到这个对象的存在状态以及对象本身。&lt;/p>
&lt;p>&lt;code>ObjectResolver&lt;/code>是可以随意拷贝和移动的，而且我们只需要把对应的方法设为默认就可以了，因为它只包含一个&lt;code>shared_ptr&lt;/code>成员。关键就是，在&lt;code>Resolve&lt;/code>方法里面要判断一下&lt;code>shared_ptr&lt;/code>本身是不是 null，如果是，说明这个&lt;code>ObjectResolver&lt;/code>是被移动过的，那么用户就不应该使用它，因为不能使用一个移动过的对象，这是由使用者来保证的，我们只需要加一个断言来帮助解决这个可能发生的 bug（实际上我在第一次使用时就发生了这个问题）。&lt;/p>
&lt;p>而&lt;code>SelfResolvable&lt;/code>是既不可以拷贝也不可以移动，这是我故意设置的，因为我压根就没打算让继承它的类拷贝和移动（比如窗口）。而且这个类的拷贝和移动语义设计起来也会比较复杂，因为我暂时用不上，所以就不过度设计了。&lt;/p>
&lt;p>最后有一点有趣的是，这里用到了一个叫做&lt;a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">curiously recurring template pattern&lt;/a>的东西，具体的可以去看看维基，就不赘述了。&lt;/p>
&lt;h2 id="update-1">Update 1&lt;/h2>
&lt;p>修改了所有的 Typo.&lt;/p>
- https://crupest.cn/posts/self-resolvable/ - crupest. 本站遵循 CC-BY-NC 4.0 协议</description></item></channel></rss>